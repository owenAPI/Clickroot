<!doctype html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />

	<link rel="manifest" href="ascii-patrol-html5.json">

	<meta name="viewport" content="width=800" />
	<meta name="theme-color" content="#000000">


    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="HandheldFriendly" content="true" />
    <meta name="mobile-web-app-capable" content="yes" />

    <meta http-equiv="Cache-Control" content="no-cache" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />


    <title>ASCII PATROL</title>

<script type="text/javascript">

/*

Copyright (C) 2016 Marcin Sokalski
All rights reserved.

ASCII PATROL ALPHA RELEASE LICENSE

You are granted a non-exclusive License to use the Software for any purposes for an unlimited period of time. The software product under this License is provided free of charge.
Even though a license fee is not paid for the use of Freeware Version software, it does not mean that there are no conditions for using such software:

* The Software may be installed and used by the Licensee for any legal purpose.

* The Software may be installed and used by the Licensee on any number of systems.

* The Software may be used solely for your personal, informational, noncommercial purposes.

* The Software MAY NOT be modified or altered in any way

* The Software MAY NOT be redistributed over public channels. The program may be redistributed freely through private means (such as e-mail), provided all of its files (including this and other documentation) remain unchanged.

* The Licensee will not have any proprietary rights in and to the Software. The Licensee acknowledges and agrees that the Licensor retains all copyrights and other proprietary rights in and to the Software.

* Use within the scope of this License is free of charge and no royalty or licensing fees shall be paid by the Licensee.

*/

	if ('serviceWorker' in navigator) {
		window.addEventListener('load', function () {
			navigator.serviceWorker.register('ascii-patrol-sw.js').then(function (registration) {
				// Registration was successful
				console.log('ServiceWorker registration successful with scope: ', registration.scope);

			}, function (err) {
				// registration failed :(
				console.log('ServiceWorker registration failed: ', err);
			});
		});
	}

/*
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-75309032-1', 'auto');
  ga('send', 'pageview');
*/

</script>
	
	<style>

		*
		{
			border:0;
			padding:0;
			margin:0;
		}
			
		canvas
		{
			position: absolute;
			display: block;
			overflow:hidden;
		}
		
		html, body
		{
			width:100%;
			height:100%;
			background-color:#000;
			overflow:hidden;
		}
		
	</style>

<script id="vs" type="x-shader/x-vertex">
	attribute vec2 xy;
	uniform float width;
	uniform float height;
	
	varying vec4 tc;
	
	void main()
	{
		float cx = xy.x * 2.0/width - 1.0;
		float cy = 1.0 - xy.y * 2.0/height;
		gl_Position = vec4(cx,cy,0.0,1.0);
		tc = vec4( xy / vec2(256.0,64.0), xy );
	}
</script>

<script id="fs" type="x-shader/x-fragment">
	precision highp float;

	uniform sampler2D fnt;
	uniform sampler2D tex;
	
	varying vec4 tc;
	
	float round(in float x)
	{
		return floor(x+0.5);
	}
	
	void main()
	{
		vec4 cell = texture2D(tex, tc.xy); // nearest

		vec2 ofs = vec2(0.0,0.0);
		
		int attr2 = 45;
		float attr  = round(cell.y * 255.0) / 16.0;
		
		float bg = floor(attr)/4.0;
		float bx = round(fract(bg)*4.0) * 128.0 / 512.0;
		float by = floor(bg)*112.0 / 512.0;

		vec4 back = texture2D(fnt, vec2(bx,by) + ofs);
		
		float fg = fract(attr)*4.0;
		float fx = round(fract(fg)*4.0) * 128.0;
		float fy = floor(fg)*112.0;

		float px = fract(tc.z)*8.0;
		float py = fract(tc.w)*14.0;
		
		float glyph = round(cell.x * 255.0) / 16.0;
		float gx = (round(fract(glyph)*16.0)*8.0 + fx + px) / 512.0;
		float gy = (floor(glyph)*14.0 + fy + py) / 512.0;

		vec4 front = texture2D(fnt, vec2(gx,gy) );
		
		gl_FragColor = mix(back,front,front.a);
	}
</script>

	
<script type="text/javascript">

function DBG(ptr)
{
	var txt = "";
	while (true)
	{
		var c = Module.HEAPU8/*.buffer*/[ptr++];
		if (!c)
			break;
		txt += String.fromCharCode(c);
	}
	console.log(txt);
}

var width = 160;
var height = 50;

var vp_x=0;
var vp_y=0;
var vp_w=width*8;
var vp_h=height*14;

var ctx;
var tex; // to be uploaded with glyphs abd attrs
var width_uniform = null;
var height_uniform = null;

var coords_rect;

var set_input;
var set_touch;

var set_output;
var set_hiscore;

var audio_ctx;
var set_audio;
var get_audio;

var get_sfx_count;
var get_sfx_arr;
var get_sfx_len;
var get_sfx_data;
var del_sfx;

var audio_node = null;
var gain_mo3_node = null;
var audio_buf = null;

var sfx_buf = null; // arr of audiocontext's buffers (all are mono 44100Hz)

// initialy silence!
var sfx_vol = 0;
var mo3_vol = 0;

var sfx_voice_map;
function PlaySfx(id, voice, loop, vol, pan)
{
	if (window.navigator.vibrate)
	{
		if (id==33)
		{
			// hack car explode event
			window.navigator.vibrate(500);	
		}

		if (id>=30 && id<=32)
		{
			// wheel jump
			window.navigator.vibrate(50);	
		}
	}

	if (sfx_buf[id])
	{
		var src_node = audio_ctx.createBufferSource();
		var vol_node = audio_ctx.createGain();

		sfx_voice_map[voice] =
		{
			'id':id,
			'src_node':src_node,
			'vol_node':vol_node,
			'vol':sfx_vol,
			'gain':vol,
			'pan':pan,
			'fade_start': 0,
			'fade_len' : 0,
		};
		
		vol_node.gain.value = vol * sfx_vol / 10000.0;
		
		src_node.buffer = sfx_buf[id];
		src_node.loop = loop!=0;
		
		src_node.onended = function()
		{
			var obj = sfx_voice_map[voice];
			if (obj)
			{
				sfx_voice_map[voice]=null;
				delete sfx_voice_map[voice];
				del_sfx(voice);
				
				obj.src_node.onended = null;
				obj.src_node.disconnect();
				obj.vol_node.disconnect();
				obj.src_node.buffer=null;
			}
		}
		
		src_node.connect(vol_node);
		vol_node.connect(audio_ctx.destination);
		
		src_node.start();
	}
}

function StopSfx(voice,fade)
{
	if (fade<=0)
	{
		if (voice==0)
		{
			for (var voice in sfx_voice_map)
			{
				sfx_voice_map[voice].src_node.onended();
			}
		}
		else
		{
			if (sfx_voice_map[voice])
				sfx_voice_map[voice].src_node.onended();
		}
	}
	else
	{
		var fade_begin = audio_ctx.currentTime;
		if (voice==0)
		{
			for (var voice in sfx_voice_map)
			{
				var obj = sfx_voice_map[voice];
				
				if (obj.fade_len==0)
				{
					obj.fade_start = fade_begin;
					obj.fade_len = fade/1000.0;
					
					var v0 = obj.gain * obj.vol / 10000.0;
					var v1 = 0.0;
					
					obj.vol_node.gain.linearRampToValueAtTime(v0, obj.fade_start);
					obj.vol_node.gain.linearRampToValueAtTime(v1, obj.fade_start + obj.fade_len);
				}
				else
				{
					var end = fade_begin + fade;
					var e = obj.fade_start + obj.fade_len;
					if ( e-end > 0 )
					{
						var delta = (fade*obj.fade_len)/(fade_begin - obj.fade_start) - fade;
						obj.fade_start = fade_begin - delta;
						obj.fade_len = fade + delta;
						
						var v0 = obj.gain * obj.vol / 10000.0;
						var v1 = 0.0;
						
						obj.vol_node.gain.linearRampToValueAtTime(v0, obj.fade_start);
						obj.vol_node.gain.linearRampToValueAtTime(v1, obj.fade_start + obj.fade_len);
					}
				}
			}
		}
		else
		if (sfx_voice_map[voice] && sfx_voice_map[voice].fade_len == 0)
		{
			var obj = sfx_voice_map[voice];
			
			obj.fade_start = fade_begin;
			obj.fade_len = fade/1000.0;
			
			var v0 = obj.gain * obj.vol / 10000.0;
			var v1 = 0.0;
			
			obj.vol_node.gain.linearRampToValueAtTime(v0, obj.fade_start);
			obj.vol_node.gain.linearRampToValueAtTime(v1, obj.fade_start + obj.fade_len);
		}
	}
}

function SetSfxParams(voice,vol,pan)
{
	if (sfx_voice_map[voice] && sfx_voice_map[voice].fade_len==0)
	{
		sfx_voice_map[voice].gain=vol;
		sfx_voice_map[voice].pan=pan;
		sfx_voice_map[voice].vol_node.gain.value = 
			sfx_voice_map[voice].gain * sfx_voice_map[voice].vol / 10000.0;
	}
}

function SetGain(mo3,sfx)
{

	if (gain_mo3_node && mo3>=0)
	{
		gain_mo3_node.gain.value = mo3/100;
	}
	else
	if (mo3>=0)
	{
		mo3_vol = mo3/100;
	}

	if (sfx>=0)
	{
		sfx_vol = sfx;
	}
}


function init_audio() 
{
	var audioContext = window.AudioContext || window.webkitAudioContext;
	
	if (!audioContext)
		return;
	
	audio_ctx = new audioContext();
	
	var bufsize = 2048;
	if (audio_ctx)
	{
		audio_node = audio_ctx.createScriptProcessor(bufsize, 0, 2);
		gain_mo3_node = audio_ctx.createGain();
		
		gain_mo3_node.gain.value = mo3_vol;
		
		gain_mo3_node.connect(audio_ctx.destination);
	}
	else
	{
		return;
	}
		
	if (audio_node && gain_mo3_node)
	{
		sfx_voice_map = {};
	
		var ptr = set_audio(2,audio_ctx.sampleRate,bufsize);
		
		var sfx_count = get_sfx_count();
		var arr_id = new Int32Array( Module.HEAPU8.buffer, get_sfx_arr(), sfx_count);
		
		sfx_buf = new Array(96);
		
		for (var sfx=0; sfx<sfx_count; sfx++)
		{
			var id   = arr_id[sfx];
			var len  = get_sfx_len(id);
			var data = new Int16Array( Module.HEAPU8.buffer, get_sfx_data(id), len);
			
			sfx_buf[id] = audio_ctx.createBuffer(1,len,44100);
			var buf = sfx_buf[id].getChannelData(0);
			
			for (var i=0; i<len; i++)
				buf[i] = data[i]/32768.0;
		}
		
		audio_buf = new Int16Array( Module.HEAPU8.buffer, ptr, bufsize*2);
	
		audio_node.onaudioprocess = function(ev)
		{
			var samples = ev.outputBuffer.length;
			get_audio(2,audio_ctx.sampleRate,samples);
			
			var left = ev.outputBuffer.getChannelData(0);
			var right = ev.outputBuffer.getChannelData(1);			
				
			for (var i=0; i<samples; i++)
			{
				left[i] = audio_buf[2*i+0] / 32768;
				right[i] = audio_buf[2*i+1] / 32768;
			}
		}
		
		audio_node.connect(gain_mo3_node);
	}
}
  
function toggleFullScreen() 
{
  if (!document.fullscreenElement &&    // alternative standard method
      !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement ) {  // current working methods
    if (document.documentElement.requestFullscreen) {
      document.documentElement.requestFullscreen();
    } else if (document.documentElement.msRequestFullscreen) {
      document.documentElement.msRequestFullscreen();
    } else if (document.documentElement.mozRequestFullScreen) {
      document.documentElement.mozRequestFullScreen();
    } else if (document.documentElement.webkitRequestFullscreen) {
      document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
    }
  } else {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    }
  }
}

function input_keyup(event)
{
    if (event.defaultPrevented) {
       return;
    }

	if (!event.ctrlKey && !event.altKey && event.keyCode!=16)
	{
		if (set_input && event.keyCode < 0x80)
		{
			var code = event.keyCode;
			var shift = event.shiftKey;
			if (event.getModifierState && code>=0x41 && code<=0x5A)
				shift ^= event.getModifierState("CapsLock");
			if (!shift && code>=0x41 && code<=0x5A)
				code += 0x20;
			set_input(code); 
		}
	}
}


var mouse_touch = false;
var mouse_x, mouse_y;
function input_mousedown(event)
{
	event.preventDefault();

	if (set_touch && event.button === 0 && !mouse_touch)
	{
		var x = event.pageX;
		var y = event.pageY;
		var id = 0;

		// convert x,y from client space pixels to canvas space glyphs
		x = Math.floor( (x - touch_rect_x) * touch_rect_u / touch_rect_w );
		y = Math.floor( (y - touch_rect_y) * touch_rect_v / touch_rect_h );

		mouse_x = x;
		mouse_y = y;

		set_touch(0x10000000,x,y,id);
		mouse_touch = true;

		console.log("BEGIN " + x + "," + y + "," + id);
	}
}

function input_mousemove(event)
{
	event.preventDefault();

	if (set_touch && mouse_touch)
	{
		var x = event.pageX;
		var y = event.pageY;
		var id = 0;

		// convert x,y from client space pixels to canvas space glyphs
		x = Math.floor( (x - touch_rect_x) * touch_rect_u / touch_rect_w );
		y = Math.floor( (y - touch_rect_y) * touch_rect_v / touch_rect_h );

		if (x != mouse_x || y != mouse_y)
		{
			mouse_x = x;
			mouse_y = y;

			set_touch(0x10000001,x,y,id);
			console.log("MOVE " + x + "," + y + "," + id);
		}
	}
}

function input_mouseup(event)
{
	event.preventDefault();

	if (set_touch && event.button === 0 && mouse_touch)
	{
		var x = event.pageX;
		var y = event.pageY;
		var id = 0;

		// convert x,y from client space pixels to canvas space glyphs
		x = Math.floor( (x - touch_rect_x) * touch_rect_u / touch_rect_w );
		y = Math.floor( (y - touch_rect_y) * touch_rect_v / touch_rect_h );

		set_touch(0x10000002, x,y,id);

		mouse_touch = false;

		console.log("END " + x + "," + y + "," + id);
	}
}


var touches = {};
var touch_mask = 0x0;

function input_touchstart(event)
{
	event.preventDefault();

	if (set_touch)
	{
		var data = event.changedTouches;
		for (var i=0; i<data.length; i++)
		{
			// no more free touches
			if (touch_mask === 0xFFFF)
				break;
				
			var id = 0;
			for (var bit=0; bit<16; bit++)
			{
				if ( (touch_mask & (1<<bit)) === 0 )
				{
					touch_mask |= 1<<bit;
					id = bit+1;
					break;
				}
			}

			var x = data[i].pageX;
			var y = data[i].pageY;
			var key = data[i].identifier;

			// convert x,y from client space pixels to canvas space glyphs
			x = (x - touch_rect_x) * touch_rect_u / touch_rect_w;
			y = (y - touch_rect_y) * touch_rect_v / touch_rect_h;

			var qx = Math.floor(x);
			var qy = Math.floor(y);

			touches[key] = { 'x':qx, 'y':qy, 'id':id, 'fx':qx+0.5-x, 'fy':qy+0.5-y };

			set_touch(0x10000000,qx,qy,id);

			console.log("BEGIN " + qx + "," + qy + "," + id + " ("+key+")");
		}
	}
}

function input_touchmove(event)
{
	event.preventDefault();

	if (set_touch)
	{
		var data = event.changedTouches;
		for (var i=0; i<data.length; i++)
		{
			var key = data[i].identifier;

			var t = touches[key];
			if (!t)
				continue;

			var x = data[i].pageX;
			var y = data[i].pageY;
			var id = t.id;

			// convert x,y from client space pixels to canvas space glyphs
			var qx = Math.floor( (x - touch_rect_x) * touch_rect_u / touch_rect_w + t.fx);
			var qy = Math.floor( (y - touch_rect_y) * touch_rect_v / touch_rect_h + t.fy);

			if (qx!= t.x || qy!= t.y)
			{
				t.x = qx;
				t.y = qy;
				set_touch(0x10000001,qx,qy,id);

				console.log("MOVE " + qx + "," + qy + "," + id + " ("+key+")");
			}
		}
	}
}

function input_touchendcancel(event)
{
	event.preventDefault();

	if (set_touch)
	{
		var data = event.changedTouches;
		for (var i=0; i<data.length; i++)
		{
			var key = data[i].identifier;

			var t = touches[key];
			if (!t)
				continue;

			var x = data[i].pageX;
			var y = data[i].pageY;
			var id = t.id;

			// convert x,y from client space pixels to canvas space glyphs
			var qx = Math.floor( (x - touch_rect_x) * touch_rect_u / touch_rect_w + t.fx);
			var qy = Math.floor( (y - touch_rect_y) * touch_rect_v / touch_rect_h + t.fy);

			set_touch(0x10000002, qx,qy,id);
			touches[key] = null;
			touch_mask &= ~(1<<(id-1));

			console.log("END " + qx + "," + qy + "," + id + " ("+key+")");
		}
	}
}

function input_keydown(event)
{
    if (event.defaultPrevented) {
       return;
    }

    var handled = false;
	
	if (!event.ctrlKey && !event.altKey && event.keyCode!=16)
	{
		if (set_input && event.keyCode < 0x80)
		{
			var code = event.keyCode;
			var shift = event.shiftKey;
			if (event.getModifierState && code>=0x41 && code<=0x5A)
				shift ^= event.getModifierState("CapsLock");
			if (!shift && code>=0x41 && code<=0x5A)
				code += 0x20;
			set_input(code | 0x80); 
			handled=true;
		}
	}
	
	
    if (event.key !== undefined) {
       if (event.key === 'Enter' && event.altKey) {
          toggleFullScreen();
       }
    } else if (event.keyIdentifier !== undefined) {
       if (event.keyIdentifier === "Enter" && event.altKey) {
          toggleFullScreen();
       }

    } else if (event.keyCode !== undefined) {
       if (event.keyCode === 13 && event.altKey) {
          toggleFullScreen();
       }
    }
    if (handled) {
       event.preventDefault();
    };
}

function SetInputHandlers(elem)
{
	elem.addEventListener('keydown', input_keydown, { passive: false });
	elem.addEventListener('keyup', input_keyup, { passive: false });
	
	elem.addEventListener('touchstart', input_touchstart, { passive: false });
	elem.addEventListener('touchmove', input_touchmove, { passive: false });
	elem.addEventListener('touchend', input_touchendcancel, { passive: false });
	elem.addEventListener('touchcancel', input_touchendcancel, { passive: false });

	//elem.addEventListener('click', function(ev) { alert(); }, { passive: false });
	elem.addEventListener('mousedown', input_mousedown, { passive: false });
	elem.addEventListener('mousemove', input_mousemove, { passive: false });
	elem.addEventListener('mouseup', input_mouseup, { passive: false });
}


var back_buffer = null;

var touch_rect_x=0;
var touch_rect_y=0;
var touch_rect_w=1;
var touch_rect_h=1;
var touch_rect_u=1;
var touch_rect_v=1;

function resize(e)
{

	var realToCSSPixels = Math.floor( window.devicePixelRatio || 1 );
	if (realToCSSPixels<1)
		realToCSSPixels = 1;
	
	var w = window.innerWidth;
	var h = window.innerHeight;

	var cell_w = 8;
	var cell_h = 14;

	var qw = w/(80*cell_w);
	var qh = h/(25*cell_h);
	var q  = Math.min(qw,qh);
	if (q < 1.0)
	{
		cell_w = (cell_w*q);
		cell_h = (cell_h*q);
	}

	width = Math.floor(w/cell_w);
	height = Math.floor(h/cell_h);

	if (width>160)
		width=160;
	if (height>50)
		height=50;
	if (width<80)
		width=80;
	if (height<25)
		height=25;
	
	ctx.canvas.width = width*cell_w * realToCSSPixels;
	ctx.canvas.height = height*cell_h * realToCSSPixels;
	
	vp_w=width*cell_w;
	vp_h=height*cell_h;

	var dw;
	var dh;
	
	if (vp_w<w-cell_w && vp_h<h-cell_h)
	{
		var zoom_x = w / vp_w;
		var zoom_y = h / vp_h;
		var zoom = Math.min(zoom_x,zoom_y);
		
		dw = Math.floor(vp_w*zoom);
		dh = Math.floor(vp_h*zoom);
	}
	else
	{
		dw = vp_w;
		dh = vp_h;
	}

	vp_x=0;
	vp_y=0;

	vp_w *= realToCSSPixels;
	vp_h *= realToCSSPixels;


	touch_rect_w = dw;
	touch_rect_h = dh;
	touch_rect_x = Math.floor( (w - dw)/2 );
	touch_rect_y = Math.floor( (h - dh)/2 );
	touch_rect_u = width;
	touch_rect_v = height;
	
	ctx.canvas.style.width = "" + dw + "px";
	ctx.canvas.style.height = "" + dh + "px";
	ctx.canvas.style.left = "" + Math.floor( (w - dw)/2 ) + "px";
	ctx.canvas.style.top = "" + Math.floor( (h - dh)/2 ) + "px";


	if (render == render_3d)
	{
		coords_rect[0] = 0; coords_rect[1] = 0; 
		coords_rect[2] = width; coords_rect[3] = 0;
		coords_rect[4] = width; coords_rect[5] = height;
		coords_rect[6] = 0; coords_rect[7] = height;		
		
		ctx.bufferData(ctx.ARRAY_BUFFER, coords_rect, ctx.STATIC_DRAW);

		ctx.uniform1f(width_uniform, width);
		ctx.uniform1f(height_uniform, height);
	}
	else
	{
		if (back_buffer)
		{
			for (var y=0; y<height; y++)
			{
				for (var x=0; x<width; x++)
				{
					var i = 4*(256*y+x);
					back_buffer[i]=0xFF;
					back_buffer[i+1]=0;
				}
			}
		}
	}
}

function init2d(c)
{
	try 
	{
		ctx = c.getContext("2d");
	}
	catch(e) 
	{
		ctx = null;
		return;
	}
	
	render = render_2d;

	window.onresize = resize;
	resize(null);	
	
	//document.getElementById("msg").innerHTML = "RENDERING: Canvas-2D";
	
	requestAnimationFrame(animate);
}

function init()
{
    var c=document.getElementById("ascii");
    img=document.getElementById("font");
	
	try 
	{
		ctx = 
			c.getContext("webgl") || 
			c.getContext("experimental-webgl");
	}
	catch(e) 
	{
		ctx = null;
	}
	
	if (!ctx)
	{
		init2d(c);
		return;		
	}
	
	render = render_3d;

	var vb = ctx.createBuffer();
	ctx.bindBuffer(ctx.ARRAY_BUFFER, vb);
	coords_rect = new Float32Array(2*4);

	ctx.activeTexture(ctx.TEXTURE1);
	var fnt = ctx.createTexture();
	ctx.bindTexture(ctx.TEXTURE_2D, fnt);
	ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE); 
	ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
	ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.NEAREST);
	ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.NEAREST);
	ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, ctx.RGBA, ctx.UNSIGNED_BYTE, img);
	
	ctx.activeTexture(ctx.TEXTURE0);
	tex = ctx.createTexture();
	ctx.bindTexture(ctx.TEXTURE_2D, tex);
	ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE); 
	ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
	ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.NEAREST);
	ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.NEAREST);
	ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, 256,64,0, ctx.RGBA, ctx.UNSIGNED_BYTE, new Uint8Array(256*64*4));
	
	var vs = ctx.createShader(ctx.VERTEX_SHADER);
	ctx.shaderSource( vs, document.getElementById('vs').innerHTML );
	ctx.compileShader(vs);
	if (!ctx.getShaderParameter(vs, ctx.COMPILE_STATUS)) 
		console.log(ctx.getShaderInfoLog(vs));

	var fs = ctx.createShader(ctx.FRAGMENT_SHADER);
	ctx.shaderSource( fs, document.getElementById('fs').innerHTML );
	ctx.compileShader(fs);
	if (!ctx.getShaderParameter(fs, ctx.COMPILE_STATUS)) 
		console.log(ctx.getShaderInfoLog(fs));
	
	var prg = ctx.createProgram();
	ctx.attachShader(prg,vs);
	ctx.attachShader(prg,fs);
	ctx.linkProgram(prg);
	ctx.useProgram(prg);
	
	// attribs
	var xy = ctx.getAttribLocation(prg, "xy");
	ctx.vertexAttribPointer(xy, 2, ctx.FLOAT, false, 0, 0);
	ctx.enableVertexAttribArray(xy);

	// uniforms
	ctx.uniform1i(ctx.getUniformLocation(prg, "tex"), 0);
	ctx.uniform1i(ctx.getUniformLocation(prg, "fnt"), 1);

	// handled in resize
	width_uniform = ctx.getUniformLocation(prg, "width");
	height_uniform = ctx.getUniformLocation(prg, "height");

	window.onresize = resize;
	resize(null);	
	
	// document.getElementById("msg").innerHTML = "RENDERING: Canvas-WebGL";
	
	requestAnimationFrame(animate);
}

var front_offset = -1;
var front_buffer = null;
var render = null;

function animate()
{
	if (set_output)
	{
		var ofs = set_output( width, height );
		
		if (front_offset != ofs || front_buffer==null)
		{
			front_buffer = new Uint8Array(Module.HEAPU8.buffer, ofs, 256*64*4);
			front_offset = ofs;
		}

		if (front_buffer)
			render();
	}
	else
	{
		// loading progress renderer
	}
	
	requestAnimationFrame(animate);
}

function render_2d()
{
	if (!back_buffer)
		back_buffer = new Uint8Array(256*64*4);
		
	// copy to screen
	for (var y=0; y<height; y++)
	{
		for (var x=0; x<width; x++)
		{
			var idx = 4*(x+y*256);
			
			var glyph = front_buffer[idx];
			var attr = front_buffer[idx+1];
			
			if (glyph!=back_buffer[idx] || attr!=back_buffer[idx+1])
			{
				back_buffer[idx] = glyph;
				back_buffer[idx+1] = attr;

				var bg = attr>>4;
				
				var bx = (bg&0x3)*128;
				var by = (bg>>2)*112;
				
				ctx.drawImage(img,bx,by,8,14,x*8,y*14,8,14);
				
				if (glyph>32 && ((attr>>4) ^ (attr&0xF))!=0)
				{
					var gx = (glyph&0xF)*8;
					var gy = (glyph>>4)*14;
					
					var fg = attr&0xF;
					
					var fx = (fg&0x3)*128 + gx;
					var fy = (fg>>2)*112 + gy;
				
					ctx.drawImage(img,fx,fy,8,14,x*8,y*14,8,14);
				}
			}
		}
	}
}

function render_3d()
{	
	ctx.texSubImage2D(ctx.TEXTURE_2D, 0, 0, 0, 256,64, ctx.RGBA, ctx.UNSIGNED_BYTE, front_buffer);
	ctx.viewport(vp_x,vp_y,vp_w,vp_h);
	ctx.drawArrays(ctx.TRIANGLE_FAN,0,4);
}


// HI SCORE
function get_hiscore(uri) {
	var get_xhr = new XMLHttpRequest();

	// detect if we are on HTTP or HTTPS
	if ('https:' == document.location.protocol)
		uri = uri.replace('http:','https:');

	get_xhr.open('GET', uri, true);

	get_xhr.onreadystatechange = function () {
		if (get_xhr.readyState == 4) {
			if (get_xhr.status == 200) {
				if (set_hiscore)
					set_hiscore(get_xhr.responseText);
			}
		}
	};

	get_xhr.send();
}

// post data, set before call to post_hiscore()
var xhr_ptr;
var xhr_siz;

function post_hiscore(uri) 
{
	// simplest way would be to read file in c++
	// pass it here as a pointer to heap
	// create a copy of it here (blob)
	// send request with formdata
	// and delete it from heap after we exit from here

	// hey! it works.

	var data = new FormData();
	var buf = new Uint8Array(Module.HEAPU8.buffer, xhr_ptr, xhr_siz);
	var blob = new Blob([buf], {type: 'application/octet-binary'});
	data.append('rec', blob);

	// detect if we are on HTTP or HTTPS
	if ('https:' == document.location.protocol)
		uri = uri.replace('http:','https:');

	var post_xhr = new XMLHttpRequest();
	post_xhr.open('POST', uri, true);

	post_xhr.onreadystatechange = function () {
		if (post_xhr.readyState == 4) {
			if (post_xhr.status == 200) {
				if (set_hiscore)
					set_hiscore(post_xhr.responseText);
			}
		}
	};

	post_xhr.send(data);
}


</script>
</head>

  <body>
 
	<canvas id='ascii' width="720" height="392"></canvas>

    <script type='text/javascript'>

    	var init_api = function () {

    		// todo:
    		// here show/create some prompt to click
    		// set click handler to it doing all the following stuff
			// (instead of doing in in init_api)

    		SetInputHandlers(window);

    		set_input = Module.cwrap('set_input', null, ['number']);
    		set_touch = Module.cwrap('set_touch', null, ['number', 'number', 'number', 'number']);

    		set_output = Module.cwrap('set_output', 'number', ['number', 'number']);
    		set_hiscore = Module.cwrap('set_hiscore', null, ['string']);

    		set_audio = Module.cwrap('set_audio', 'number', ['number', 'number', 'number']);
    		get_audio = Module.cwrap('get_audio', null, ['number', 'number', 'number']);

    		get_sfx_count = Module.cwrap('get_sfx_count', 'number', []);
    		get_sfx_arr = Module.cwrap('get_sfx_arr', 'number', []);
    		get_sfx_len = Module.cwrap('get_sfx_len', 'number', ['number']);
    		get_sfx_data = Module.cwrap('get_sfx_data', 'number', ['number']);
    		del_sfx = Module.cwrap('del_sfx', null, ['number']);


    		if (set_audio && get_audio)
    			init_audio();

    		// setTimeout(fade_navi, 2000/*12000*/);
    	};

	var Module = {
		preRun: [],
		postRun: [init_api],
		
		  print: function(text) { /*console.log(text)*/ },
		  printErr: function(text) { /*console.error(text)*/ }
  
	};
  

	(function() {
	  var memoryInitializer = 'temp.html.mem?v=1.5';
	  if (typeof Module['locateFile'] === 'function') {
		memoryInitializer = Module['locateFile'](memoryInitializer);
	  } else if (Module['memoryInitializerPrefixURL']) {
		memoryInitializer = Module['memoryInitializerPrefixURL'] + memoryInitializer;
	  }
	  var xhr = Module['memoryInitializerRequest'] = new XMLHttpRequest();
	  xhr.open('GET', memoryInitializer, true);
	  xhr.responseType = 'arraybuffer';
	  xhr.send(null);
	})();

	var script = document.createElement('script');
	script.src = "temp.js?v=1.5";
	document.body.appendChild(script);

	</script>

<div style="display:none">
<img id="font" src="8x14x16.png" onload = "init()">
</div>

  </body>
</html>
